# python字符编码

### 基础概念

#### 字节

* 字节（Byte）是计算机中数据存储的基本单元，一字节等于一个8位的比特，计算机中的所有数据，不论是保存在磁盘文件上的还是网络上传输的数据（文字、图片、视频、音频文件）都是由字节组成的。

#### 字符

* 字符一个信息单位，它是各种文字和符号的统称，比如一个英文字母是一个字符，一个汉字是一个字符，一个标点符号也是一个字符

#### 字符编码

* 字符编码（Character Encoding）是将字符集中的字符码映射为字节流的一种具体实现方案，常见的字符编码有 ASCII 编码、UTF-8 编码、GBK 编码等。某种意义上来说，字符集与字符编码有种对应关系，例如 ASCII 字符集对应 有 ASCII 编码。ASCII 字符编码规定使用单字节中低位的7个比特去编码所有的字符。例如"A" 的编号是65，用单字节表示就是0×41，因此写入存储设备的时候就是b'01000001'。

#### 编码、解码

* 编码的过程是将字符转换成字节流，解码的过程是将字节流解析为字符。

### ASCII

#### 说到字符编码，要从计算机的诞生开始讲起，计算机发明于美国，在英语世界里，常用字符非常有限，26个字母（大小写）、10个数字、标点符号、控制符，这些字符在计算机中用一个字节的存储空间来表示绰绰有余，因为一个字节相当于8个比特位，8个比特位可以表示256个符号。于是美国国家标准协会ANSI制定了一套字符编码的标准叫 ASCII(American Standard Code for Information Interchange)，每个字符都对应唯一的一个数字，比如字符 "A" 对应数字是65，"B" 对应 66，以此类推。

### GBK(MBCS)(ANSI)

#### (中国人自己弄了一套叫 GB2312 的双字节字符编码，又称GB0)GB2312 编码共收录了6763个汉字，同时他还兼容 ASCII，GB 2312的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆99.75%的使用频率，不过 GB2312 还是不能100%满足中国汉字的需求，对一些罕见的字和繁体字 GB2312 没法处理，后来就在GB2312的基础上创建了一种叫 GBK 的编码，GBK 不仅收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。同样 GBK 也是兼容 ASCII 编码的，对于英文字符用1个字节来表示，汉字用两个字节来标识。

### Unicode

#### GBK仅仅只是解决了我们自己的问题，但是计算机不止是美国人和中国人用啊，还有欧洲、亚洲其他国家的文字诸如日文、韩文全世界各地的文字加起来估计也有好几十万，这已经大大超出了ASCII 码甚至GBK 所能表示的范围了，虽然各个国家可以制定自己的编码方案，但是数据在不同国家传输就会出现各种各样的乱码问题。如果只用一种字符编码就能表示地球甚至火星上任何一个字符时，问题就迎刃而解了。是它，是它，就是它，我们的小英雄，统一联盟国际组织提出了Unicode 编码，Unicode 的学名是"Universal Multiple-Octet Coded Character Set"，简称为UCS。它为世界上每一种语言的每一个字符定义了一个唯一的字符码，Unicode 标准使用十六进制数字表示，数字前面加上前缀 U+，比如字母『A』的Unicode编码是 U+0041，汉字『中』的Unicode 编码是U+4E2D

### utf-8

#### UTF-8（Unicode Transformation Format）作为 Unicode 的一种实现方式，广泛应用于互联网，它是一种变长的字符编码，可以根据具体情况用1-4个字节来表示一个字符。比如英文字符这些原本就可以用 ASCII 码表示的字符用UTF-8表示时就只需要一个字节的空间，和 ASCII 是一样的。对于多字节（n个字节）的字符，第一个字节的前n为都设为1，第n+1位设为0，后面字节的前两位都设为10。剩下的二进制位全部用该字符的unicode码填充。

以『好』为例，『好』对应的 Unicode 是597D，对应的区间是 0000 0800--0000 FFFF，因此它用 UTF-8 表示时需要用3个字节来存储，597D用二进制表示是： 0101100101111101，填充到 1110xxxx 10xxxxxx 10xxxxxx 得到 11100101 10100101 10111101，转换成16进制是 e5a5bd，因此『好』的 Unicode 码 U+597D 对应的 UTF-8 编码是 "E5A5BD"。

```
a = '好'
# "597D"
​
# 11100101 10100101 10111101
​
#   0101100101111101
​
#   0101 1001 0111 1101
​
​
b = a.encode('utf-8')
print('\u597d')
c = a.encode('GBK')
print(b)
print(c)
```

```
print(int("007F", 16))
print(int("0080", 16))
print("\u07FF")
print(bin(int('07FF', 16)))
print(int('111111111111', 2))
print(int("07FF", 16))
print(int("FFFF", 16))
​
```

```
print(bin(int('597D', 16)))
print(hex(int('111001011010010110111101', 2)))
```
